# Implemented Architecture: MetaMask Advanced Permissions (ERC-7715)

## Implementation Status

| Component | File | Status |
|-----------|------|--------|
| MetaMask SDK Client | [`metamask.rs`](../src/metamask.rs) | ✅ Implemented |
| Permission Wallet Adapter | [`wallet.rs`](../src/wallet.rs) | ✅ Implemented |
| Configuration System | [`config.rs`](../src/config.rs) | ✅ Implemented |
| WebSocket Streaming | [`websocket.rs`](../src/websocket.rs) | ✅ Implemented |
| Position Exit Logic | [`positions.rs`](../src/positions.rs) | ✅ Implemented |
| Dashboard UI | [`dashboard/index.html`](../dashboard/index.html) | ✅ Implemented |
| Arbitrage Detection | [`arb.rs`](../src/arb.rs) | ✅ Implemented |
| Execution Engine | [`execution.rs`](../src/execution.rs) | ✅ Implemented |

---

## 1. Purpose of This Migration

PolyShark was originally designed as a **paper-trading arbitrage engine** for Polymarket, focused on detecting **logical inconsistencies** across linked prediction markets.

This migration upgrades PolyShark into a **permissioned on-chain agent** by integrating **MetaMask Advanced Permissions (ERC-7715)**, allowing the bot to **execute trades automatically on behalf of a user** within strict, user-defined limits.

This aligns directly with MetaMask’s vision for safer automation and improved wallet UX.
Source: MetaMask Advanced Permissions overview

---

## 2. High-Level Architecture (Implemented)

> **Status:** ✅ Fully Implemented in Rust code

### Original Design (Legacy)

```
Simulated USDC Wallet
↓
Market Simulation
↓
Arbitrage Engine
↓
PnL Tracker
```

### Implemented Architecture (V1)

```
MetaMask Smart Account (ERC-7715)
↓
Advanced Permission (Daily USDC Limit)
↓
PolyShark Agent (Rust)
↓
Polymarket Contracts
↑
Envio Indexer (Market State)
```

Key shift:
**Execution authority moves from PolyShark → MetaMask-enforced permissions**.

Source: Smart Accounts Kit design

---

## 3. Wallet Layer Migration (`wallet.rs`)

### Original Design

* Simulated USDC balance
* Internal checks for position sizing
* No external enforcement

### New Design

* Wallet becomes a **permission-aware adapter**
* No balance simulation
* Spend safety enforced by **ERC-7715 permission constraints**

**New responsibilities**

* Track:

  * Daily spend limit
  * Spent amount (derived from executed txs)
  * Open positions
* Reject trades when remaining allowance is insufficient

This ensures PolyShark **cannot exceed user-approved limits**, even if the bot logic is faulty.

Source: ERC-7715 enforcement model

---

## 4. Market Data Migration (`market.rs`)

### Original Design

* Synthetic markets
* Randomized price drift

### Hackathon Integration

* Market state is sourced from **Envio**
* Envio indexes:

  * Market prices
  * Liquidity
  * Outcome states

PolyShark continues to consume market data via the same interface:

```rust
fn get_market_state(market_id) -> MarketState
```

Only the backend implementation changes.

This keeps the arbitrage logic untouched while making the system **chain-aware and demo-ready**.

Source: Envio HyperSync + GraphQL APIs

---

## 5. Constraint Engine (`constraint.rs`)

**No changes required.**

Logical constraints such as:

* `YES + NO = 1`
* Multi-market consistency

remain fully off-chain and deterministic.

This separation is intentional:

* Constraints = reasoning layer
* Permissions = execution safety layer

Judges explicitly value this distinction in automation-focused projects.
Source: Hackathon judging emphasis on automation correctness

---

## 6. Arbitrage Execution (`arb.rs`)

### New Pre-Execution Guard

Before any trade is executed:

1. Fetch remaining ERC-7715 allowance
2. Compare with required trade cost
3. Execute only if sufficient allowance exists

```rust
if remaining_allowance >= trade_cost {
    execute_trade();
}
```

This makes the permission **actively visible in the trading logic**, which is critical for hackathon evaluation.

Source: Advanced Permissions execution semantics

---

## 7. Agent Loop (`engine.rs`)

The main loop is upgraded into a **continuous on-chain agent**:

1. Pull indexed market data (Envio)
2. Detect logical mispricing
3. Validate permission allowance
4. Execute trade via Smart Account
5. Log execution and allowance usage

Once permission is granted, **no further wallet confirmations are required**.

This directly demonstrates improved wallet UX, which is a core judging criterion.

Source: Hackathon description (Wallet UX focus)

---

## 8. Advanced Permission Specification

PolyShark requests the following permission:

* **Type:** Spend permission
* **Token:** USDC
* **Limit:** 10 USDC per day
* **Scope:** Polymarket trading adapter
* **Duration:** 30 days

User-facing explanation:

> “PolyShark may automatically trade up to 10 USDC per day on your behalf.
> You can revoke this permission at any time.”

This mirrors MetaMask’s canonical example almost exactly.

Source: ERC-7715 example use cases

---

## 9. Demo-Critical UX Flow

1. User connects MetaMask
2. User grants daily USDC permission
3. PolyShark agent starts
4. Trades execute **without additional popups**
5. Allowance updates live in dashboard

This flow satisfies:

* Smart Accounts usage
* Advanced Permissions visibility
* Automation without friction

Source: Demo requirements

---

## 10. Why This Migration Matters

This integration turns PolyShark into:

* A **real agent**, not a bot script
* A **permission-safe automation system**
* A strong example of **ERC-7715 done right**

Most automation projects rely on trust.
PolyShark relies on **cryptographically enforced permissions**.

That distinction is the entire point of this hackathon.
Source: MetaMask Advanced Permissions motivation